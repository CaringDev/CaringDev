---
layout: post
title: "An application of structural typing"
subtitle: "Transforming XML data using the F# XML type provider"
date: 2016-06-04
---
At some point you'll find yourself doing [ETL](https://en.wikipedia.org/wiki/Extract,_transform,_load "Extract, Transform, Load").
Whether it's loading a few GB of data into SQL Server or consuming tiny MQ messages, one step is to parse (and potentially validate) data. 
Usually, this is rather boring and tedious work. Unless...

## The problem

Consider the following, vastly simplified messages:
<div class="row">
<div class="col-sm-6 col-xs-12">
{% highlight xml %}
<?xml version="1.0" encoding="UTF-8" ?>
<message xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Available>Foo</Available>
  <Nil xsi:nil="true"/>
  <Missing>42</Missing>
  <Missing_Nil>1337</Missing_Nil>
</message>
{% endhighlight %}
</div>
<div class="col-sm-6 col-xs-12">
{% highlight xml %}
<?xml version="1.0" encoding="UTF-8" ?>
<message>
  <Available>Bar</Available>
  <Nil>3.141</Nil>
</message>
{% endhighlight %}
</div>
</div>

### Extract ###
A very convenient way of working with (unknown to the programmer) data in F# are so-called type providers.

> An F# type provider is a component that provides types, properties, and methods for use in your program.
[...]
Writing these types manually is very time-consuming and difficult to maintain.
A common alternative is to use a code generator which adds files to your project
[...]\\
\\
[Visual F# docs](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/type-providers "MSDN")

The [XMLProvider](https://fsharp.github.io/FSharp.Data/library/XmlProvider.html) is configurable with a list of messages:
{% highlight xml %}
<?xml version="1.0" encoding="UTF-8" ?>
<messages xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <message>
    <Available>Foo</Available>
    <Nil xsi:nil="true"/>
    <Missing>42</Missing>
    <Missing_Nil>1337</Missing_Nil>
  </message>
  <message>
    <Available>Bar</Available>
    <Nil>3.141</Nil>
  </message>
  <message>
    <Available></Available>
    <Nil>2.718</Nil>
    <Missing_Nil xsi:nil="true"/>
  </message>
</messages>
{% endhighlight %}

The generated type is then used to load a file containing only one `message` element:
{% highlight fsharp %}
type XmlMessage = XmlProvider<"messageSamples.xml", SampleIsList=true, Global=true>
let message = XmlMessage.Load("message.xml")
{% endhighlight %}

**E**xtraction, fast and easy, <i class="fi-check"></i>

### Transform ###

The type provider generates types equivalent to the following ones:
{% highlight fsharp %}
type Message = {
    Available : string
    Missing : string option
    Nil : Nil
    MissingNil : MissingNil option
}
 
and Nil = {
    Nil : bool option
    Value : decimal
}
 
and MissingNil = {
    Nil : bool option
    Value : int
}
{% endhighlight %}

For *l*oading however, data should be in a format suitable for sending to a database:
{% highlight fsharp %}
type DbMessage = {
    Available : string
    Missing : string
    Nil : Nullable<decimal>
    MissingNil : Nullable<int>
}
{% endhighlight %}
Again, this type is generated by a type provider: this time [SQLProvider](https://fsprojects.github.io/SQLProvider/).

<p class="alert alert-danger">Show na√Øve approach.</p>

But I was concerned about **duplicated code** for extracting potentially nillable, optional values.

## The solution

<p class="alert alert-danger">Explain why reference type options are fine</p>

The missing piece is a transformation from n*i*llable to n*u*llable:
<div class="row">
<div class="col-md-5 col-sm-6 col-xs-12">
{% highlight fsharp %}
type Nil = {
    Nil : bool option
    Value : decimal
}
{% endhighlight %}
</div>
<div class="col-md-2 hidden-xs hidden-sm text-center"><i class="fi-arrow-right x2"></i></div>
<div class="col-xs-12 visible-xs text-center"><i class="fi-arrow-down x2"></i></div>
<div class="col-md-5 col-sm-6 col-xs-12">
{% highlight fsharp %}
type Record = {
    Nil : Nullable<decimal>
}
{% endhighlight %}
</div>
</div>
In a dynamic language, we would probably just assign `Value`.
In a typed mainstream language (such as C#) we might make `Nil` implement an interface (an use-case for partial classes) or use reflection.
While being safer, implementing the interface is more work.\\
In F# however (and in many languages supporting structural typing), there's a thing called static type constraints and specifically member constraints:
{% highlight fsharp %}
open System

let inline value x =
    match (^N : (member Nil : bool option) x) with
    | Some true -> Nullable()
    | _ ->
        let v = (^N : (member Value : 'V) x)
        Nullable v
{% endhighlight %}
Executing the above snippet in `fsi` yields:
{% highlight fsharp %}
val inline valueOf :
  x: ^N -> Nullable<'V>
    when  ^N : (member get_Nil :  ^N -> bool option) and
          ^N : (member get_Value :  ^N -> 'V) and 'V : (new : unit ->  'V) and
         'V : struct and 'V :> ValueType
{% endhighlight %}

<p class="alert alert-danger">Show complete transform</p>

### Conclusion ###

<p class="alert alert-danger">???</p>